
import os
import sys
import shutil
import casadi as cs
import numpy as np
from copy import copy
import matplotlib
import matplotlib.pyplot as plt
from acados_template import AcadosOcp, AcadosOcpSolver, AcadosModel
from math import sqrt
import time
from collections import deque
from tqdm import trange

class px4_quad:
    def __init__(self):
        # Quadrotor intrinsic parameters
        self.J = np.array([.03, .03, .06])  # N m s^2 = kg m^2
        self.mass = 1.5  # kg

        # Length of motor to CoG segment
        self.length = 0.47 / 2  # m
        self.max_thrust = 20
        self.g = np.array([[0], [0], [9.81]])  # m s^-2
        h = np.cos(np.pi / 4) * self.length
        self.x_f = np.array([h, -h, -h, h])
        self.y_f = np.array([-h, -h, h, h])
        self.c = 0.013  # m   (z torque generated by each motor)
        self.z_l_tau = np.array([-self.c, self.c, -self.c, self.c])

        # Input constraints
        self.max_input_value = 2  # Motors at full thrust
        self.min_input_value = -2  # Motors turned off
        self.min_u = self.min_input_value
        self.max_u = self.max_input_value



def linear_quad_model():

    # Declare model variables
    roll = cs.MX.sym('roll')  # position
    pitch = cs.MX.sym('pitch')
    yaw = cs.MX.sym('yaw')

    x_ = cs.MX.sym('x_')
    y_ = cs.MX.sym('y_')
    z_ = cs.MX.sym('z_')

    p = cs.MX.sym('p')
    q = cs.MX.sym('q')
    r = cs.MX.sym('r')

    vx = cs.MX.sym('vx')
    vy = cs.MX.sym('vy')
    vz = cs.MX.sym('vz')
    # Full state vector (13-dimensional)
    x = cs.vertcat(x_,y_,z_,roll,pitch,yaw,vx,vy,vz,p,q,r)
    state_dim = 12

    # Control input vector
    u1 = cs.MX.sym('u1')
    u2 = cs.MX.sym('u2')
    u3 = cs.MX.sym('u3')
    u4 = cs.MX.sym('u4')
    u = cs.vertcat(u1, u2, u3, u4)

    my_quad = px4_quad()
    # p_dynamics
    pos_dynamics = cs.vertcat(vx,vy,vz)

    #q_dynamics
    angle_dynamics = cs.vertcat(
        p+r*(cs.cos(roll) * cs.tan(pitch))+q*(cs.sin(roll)*cs.tan(pitch)),
        q*cs.cos(roll) - r*cs.sin(roll),
        r*(cs.cos(roll)/cs.cos(pitch)) + q * (cs.sin(roll)/cs.cos(pitch)))

    # v_dynamics
    g = -9.81
    ft = (u1 + u2 + u3 + u4)*my_quad.max_thrust
    taux = (u3 - u1)*my_quad.max_thrust*my_quad.length
    tauy = (u4 - u2)*my_quad.max_thrust*my_quad.length
    tauz = (u2 + u4 - u1 - u3)*my_quad.max_thrust*my_quad.length
    v_dynamics = cs.vertcat(
        r*vy-q*vz-g*cs.sin(pitch),
        p*vz-r*vx+g*cs.sin(roll)*cs.cos(pitch),
        q*vx-p*vy + g*cs.cos(pitch)*cs.cos(roll) + ft/my_quad.mass)
    #w_dynamics 
    w_dynamics = cs.vertcat(
            (my_quad.J[1] - my_quad.J[2])/my_quad.J[0] * r * q + taux/my_quad.J[0],
            (my_quad.J[2] - my_quad.J[0])/my_quad.J[1] * r * p + tauy/my_quad.J[1],
            (my_quad.J[0] - my_quad.J[1])/my_quad.J[2] * p * q + tauz/my_quad.J[2])

    
    pdot = cs.MX.sym('pdot', 3)  # position
    qdot = cs.MX.sym('adot', 3)  # angle roll pitch yaw
    vdot = cs.MX.sym('vdot', 3)  # velocity
    rdot = cs.MX.sym('rdot', 3)  # angle rate
    xdot = cs.vertcat(pdot, qdot, vdot, rdot)

    normails = cs.vertcat(pos_dynamics, angle_dynamics, v_dynamics, w_dynamics)
    f_impl = xdot - normails

    model_name = 'px4_quad_linear_model'

    # Dynamics model
    model = AcadosModel()
    model.f_expl_expr = normails
    model.f_impl_expr = f_impl
    model.x = x
    model.xdot = xdot
    model.u = u
    model.p = []
    model.name = model_name


    return model

def DT_linear_model(dT):
    model = linear_quad_model()
    x = model.x
    u = model.u

    ode = cs.Function('ode',[x, u], [model.f_expl_expr])

    # set up Rk4
    k1 = ode(x,       u)
    k2 = ode(x+dT/2*k1,u)
    k3 = ode(x+dT/2*k2,u)
    k4 = ode(x+dT*k3,  u)
    xf = x + dT/6 * (k1 + 2*k2 + 2*k3 + k4)

    model.disc_dyn_expr = xf
    return model

def kernel(x1, x2,sigf,l):
    x1 = x1.T
    x2 = x2.T
    dist_matrix = np.sum(x1**2, 1).reshape(-1, 1) + np.sum(x2**2, 1) - 2 * np.dot(x1, x2.T)
    return sigf ** 2 * np.exp(-0.5 / l ** 2 * dist_matrix)

def DT_gp_model(dT,down_sample_factor,name):
    t_start = time.time()
    model = linear_quad_model()
    x = model.x
    u = model.u

    ode = cs.Function('ode',[x, u], [model.f_expl_expr])
    # set up Rk4
    k1 = ode(x,       u)
    k2 = ode(x+dT/2*k1,u)
    k3 = ode(x+dT/2*k2,u)
    k4 = ode(x+dT*k3,  u)
    xf = x + dT/6 * (k1 + 2*k2 + 2*k3 + k4)
    # fit gp model
    predictA = np.genfromtxt("model_predict_A.out", delimiter=",")
    measurementA = np.genfromtxt("measurements_A.out", delimiter=",")
    predictB = np.genfromtxt("model_predict_B.out", delimiter=",")
    measurementB = np.genfromtxt("measurements_B.out", delimiter=",")
    predictC = np.genfromtxt("model_predict_C.out", delimiter=",")
    measurementC = np.genfromtxt("measurements_C.out", delimiter=",")

    ind = 20
    measurementA = measurementA[:,:-ind]
    predictA = predictA[:,:-ind]
    ind = 700
    measurementB = measurementB[:,:-ind]
    predictB = predictB[:,:-ind]
    ind = 20
    measurementC = measurementC[:,:-ind]
    predictC = predictC[:,:-ind]

    input_state_A = measurementA[:,0:-1]
    error_y_A = measurementA[:,1:] - predictA[:,1:]
    input_state_B = measurementB[:,0:-1]
    error_y_B = measurementB[:,1:] - predictB[:,1:]
    input_state_C = measurementC[:,0:-1]
    error_y_C = measurementC[:,1:] - predictC[:,1:]

    input_state = np.concatenate((input_state_A,input_state_B,input_state_C),axis=1)[:,::down_sample_factor]
    error_y = np.concatenate((error_y_A,error_y_B,error_y_C),axis=1)[:,::down_sample_factor]
    print('SIZE OF training set is : ')
    print(input_state.shape)

    

    sig_f = np.std(error_y)
    X = input_state
    Y = error_y
    l =  1
    L = np.diag(np.ones(  X.shape[0]  ) * l)
    L = L**2
    K = kernel(X,X,sig_f,l)
    error = cs.MX.sym('error',Y.shape[0],1)
    x1 = x.T
    x2 = X.T
    dist_matrix = cs.sum2(x1**2) + cs.sum2(x2**2) - ((cs.mtimes(x1, x2.T))*2).T
    Kstar = (sig_f ** 2 * np.exp(-0.5 / l ** 2 * dist_matrix)).T
    error = cs.mtimes ( cs.mtimes(Kstar,np.linalg.inv(K) ), Y.T ).T

    t_end = time.time()

    
    print('time spend :',t_end - t_start)
    print('====================fited========================')
    model.name = f'px4_GP_model_{name}'
    model.disc_dyn_expr = xf + error
    return model

def acados_settinngs_linear(acados_models,solver_options = None,t_horizon = 1,N = 20):
    
    my_quad = px4_quad()
    q_cost = np.array([4, 4, 10, 1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1])
    r_cost = np.array([0.5, 0.5, 0.5, 0.5])
    
    


    nx = acados_models.x.size()[0]
    nu = acados_models.u.size()[0]
    ny = nx + nu
    n_param = acados_models.p.size()[0] if isinstance(acados_models.p, cs.MX) else 0
    ocp = AcadosOcp()
    ocp.model = acados_models
    ocp.dims.N = N
    ocp.solver_options.tf = t_horizon

    # Initialize parameters

    ocp.dims.np = n_param
    ocp.parameter_values = np.zeros(n_param)

    ocp.cost.cost_type = 'LINEAR_LS'
    ocp.cost.cost_type_e = 'LINEAR_LS'
    ocp.cost.W = np.diag(np.concatenate((q_cost, r_cost)))
    ocp.cost.W_e = np.diag(q_cost)
    terminal_cost = 0 if solver_options is None or not solver_options["terminal_cost"] else 1
    ocp.cost.W_e *= 1

    ocp.cost.Vx = np.zeros((ny, nx))
    ocp.cost.Vx[:nx, :nx] = np.eye(nx)
    ocp.cost.Vu = np.zeros((ny, nu))
    ocp.cost.Vu[-4:, -4:] = np.eye(nu)

    ocp.cost.Vx_e = np.eye(nx)

    # Initial reference trajectory (will be overwritten)
    x_ref = np.zeros(nx)
    ocp.cost.yref = np.concatenate((x_ref, np.array([0.0, 0.0, 0.0, 0.0])))
    ocp.cost.yref_e = x_ref

    ocp.constraints.x0 = x_ref

    # Set constraints
    ocp.constraints.lbu = np.array([my_quad.min_u] * 4)
    ocp.constraints.ubu = np.array([my_quad.max_u] * 4)
    ocp.constraints.idxbu = np.array([0, 1, 2, 3])
    # Solver options
    # PARTIAL_CONDENSING_HPIPM
    # FULL_CONDENSING_HPIPM

    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'DISCRETE'
    ocp.solver_options.print_level = 0
    ocp.solver_options.nlp_solver_type = 'SQP_RTI'

    acados_solver = AcadosOcpSolver(ocp, json_file='acados_ocp.json')
    print('=============================FINISHED LS ACADOS SOLVER SETTINGS ===========================')
    return acados_solver

def acados_settinngs_nonlinear_LS(acados_models,solver_options = None,t_horizon = 1,N = 20,build=True, generate=True):
    
    my_quad = px4_quad()
    q_cost = np.array([4, 4, 10, 1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1])
    r_cost = np.array([0.5, 0.5, 0.5, 0.5])
    

    nx = acados_models.x.size()[0]
    nu = acados_models.u.size()[0]
    ny = nx + nu
    ny_e = nx

    n_param = acados_models.p.size()[0] if isinstance(acados_models.p, cs.MX) else 0
    ocp = AcadosOcp()
    ocp.model = acados_models
    ocp.dims.N = N
    ocp.solver_options.tf = t_horizon

    # Initialize parameters

    #ocp.dims.np = n_param
    #ocp.parameter_values = np.zeros(n_param)

    ocp.cost.cost_type = 'NONLINEAR_LS'
    ocp.cost.cost_type_e = 'NONLINEAR_LS'
    print('===========================the sorver type is NONLINEAR =====================================')
    print('=============================================================================================')

    ocp.model.cost_y_expr = cs.vertcat(ocp.model.x, ocp.model.u)
    ocp.model.cost_y_expr_e = ocp.model.x
    


    ocp.cost.W = np.diag(np.concatenate((q_cost, r_cost)))
    ocp.cost.W_e = np.diag(q_cost)
    ocp.cost.W_e *= 1
    print('==============================SET WEIGHT MATRIX @W @We======================================')

    # Initial reference trajectory (will be overwritten)
    x_ref = np.zeros(nx)
    ocp.cost.yref = np.concatenate((x_ref, np.array([0.0, 0.0, 0.0, 0.0])))
    ocp.cost.yref_e = x_ref
    ocp.constraints.x0 = x_ref

    # Set constraints
    ocp.constraints.lbu = np.array([my_quad.min_u] * 4)
    ocp.constraints.ubu = np.array([my_quad.max_u] * 4)
    ocp.constraints.idxbu = np.array([0,1,2,3])
    print('==============================SET HARD CONSTRAINS lbu lbx idxbu ============================')
    # Solver options
    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'DISCRETE'
    ocp.solver_options.print_level = 0
    ocp.solver_options.nlp_solver_type = 'SQP_RTI'
    #ocp.solver_options.regularize_method = 'CONVEXIFY'
    ocp.solver_options.nlp_solver_max_iter = 100
    print('=======SET Solver options : PARTIAL_CONDENSING_HPIPM  : GAUSS_NEWTON : DISCRETE : SQP_RTI=======')
    t1 = time.time()

    #AcadosOcpSolver.generate(ocp, json_file='acados_ocp.json')
    #AcadosOcpSolver.build(ocp.code_export_directory, with_cython=True)
    #acados_solver = AcadosOcpSolver.create_cython_solver('acados_ocp.json')

    acados_solver = AcadosOcpSolver(ocp, json_file='acados_ocp.json',build=build, generate=generate)
    t2 = time.time()
    print('=============================FINISHED nonlinear_LS ACADOS SOLVER SETTINGS ===========================')
    print('time for build the solver:',t2-t1)
    return acados_solver

def acados_settinngs_nonlinear_LS2(acados_models,solver_options = None,t_horizon = 1,N = 20):
    
    my_quad = px4_quad()
    q_cost = np.array([4, 4, 10, 1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1])
    r_cost = np.array([0.5, 0.5, 0.5, 0.5])
    

    nx = acados_models.x.size()[0]
    nu = acados_models.u.size()[0]
    ny = nx + nu
    ny_e = nx

    n_param = acados_models.p.size()[0] if isinstance(acados_models.p, cs.MX) else 0
    ocp = AcadosOcp()
    ocp.model = acados_models
    ocp.dims.N = N
    ocp.solver_options.tf = t_horizon

    # Initialize parameters

    #ocp.dims.np = n_param
    #ocp.parameter_values = np.zeros(n_param)

    ocp.cost.cost_type = 'NONLINEAR_LS'
    ocp.cost.cost_type_e = 'NONLINEAR_LS'
    print('===========================the sorver type is NONLINEAR =====================================')
    print('=============================================================================================')

    ocp.model.cost_y_expr = cs.vertcat(ocp.model.x, ocp.model.u)
    ocp.model.cost_y_expr_e = ocp.model.x
    


    ocp.cost.W = np.diag(np.concatenate((q_cost, r_cost)))
    ocp.cost.W_e = np.diag(q_cost)
    ocp.cost.W_e *= 1
    print('==============================SET WEIGHT MATRIX @W @We======================================')

    # Initial reference trajectory (will be overwritten)
    x_ref = np.zeros(nx)
    ocp.cost.yref = np.concatenate((x_ref, np.array([0.0, 0.0, 0.0, 0.0])))
    ocp.cost.yref_e = x_ref
    ocp.constraints.x0 = x_ref

    # Set constraints
    ocp.constraints.lbu = np.array([0] * 4)
    ocp.constraints.ubu = np.array([0.2] * 4)
    ocp.constraints.idxbu = np.array([0,1,2,3])
    print('==============================SET HARD CONSTRAINS lbu lbx idxbu ============================')
    # Solver options
    ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'DISCRETE'
    ocp.solver_options.print_level = 0
    ocp.solver_options.nlp_solver_type = 'SQP_RTI'
    ocp.code_export_directory = '/home/shiqi/acados_test_1/c_generated_code2'

    #ocp.solver_options.regularize_method = 'CONVEXIFY'
    ocp.solver_options.nlp_solver_max_iter = 100
    print('=======SET Solver options : PARTIAL_CONDENSING_HPIPM  : GAUSS_NEWTON : DISCRETE : SQP_RTI=======')
    t1 = time.time()
    AcadosOcpSolver.generate(ocp, json_file='acados_ocp2.json')
    AcadosOcpSolver.build(ocp.code_export_directory, with_cython=True)
    print('==========================000000000000000000000000==============================')
    print(ocp.code_export_directory)
    acados_solver = AcadosOcpSolver.create_cython_solver('acados_ocp2.json')
    t2 = time.time()
    print('=============================FINISHED nonlinear_LS ACADOS SOLVER SETTINGS ===========================')
    print('time for build the solver:',t2-t1)
    return acados_solver

def run_solver(N,acados_solver,initial_state,ref):
    #print('RUN_ACADOS solver ============== start iter ###')
    u_target = np.zeros((N+1,4))
    ref = np.concatenate((ref, u_target),axis = 1)
    for j in range(N):
        acados_solver.set(j, "yref", ref[j])
    acados_solver.set(N, "yref", ref[N][:-4])
    
    # Set initial state.
    x_init = initial_state
    x_init = np.stack(x_init)
    # Set initial condition, equality constraint
    acados_solver.set(0, 'lbx', x_init)
    acados_solver.set(0, 'ubx', x_init)

    # Solve OCP
    acados_solver.solve()
    # get vx vy vz 
    x_next = acados_solver.get(1, "x")
    vx_next = x_next[6]
    vy_next = x_next[7]
    vz_next = x_next[8]
    p_next = x_next[9]
    q_next = x_next[10]
    r_next = x_next[11]	
    control = acados_solver.get(0, "u")
    
    print('cpu time:')
    print(acados_solver.get_stats('time_tot'))


    #print('CPU time for integrator:')
    #print(acados_solver.get_stats('time_sim'))

    #print('CPU time qp solution:')
    #print(acados_solver.get_stats('time_qp'))

    #print('number of SQP iterations:')
    #print(acados_solver.get_stats('sqp_iter'))


    return vx_next,vy_next,vz_next,p_next,q_next,r_next,control


def solve_DT_nextState(model,input_u ,current_x):
    x = model.x
    u = model.u
    xf = model.disc_dyn_expr
    DTsolution = cs.Function('f',[u,x],[xf])
    result = DTsolution(input_u,current_x)

    return result

def set_loop_ref(discretization_dt = 0.05,radius = 8,z = 5,v_average = 4,sim_t = 50):
    lin_acc = 1
    t_speedup = v_average/lin_acc
    t_speeddown = t_speedup
    t_uniform_circular = sim_t - t_speedup*2
    angle_acc = lin_acc / radius  # rad/s^2
    t_speedup_points = np.linspace(start = 0, stop = t_speedup, num = int(t_speedup/discretization_dt)+1)
    angle_points_1 = 0.5 * angle_acc * t_speedup_points**2
    anglevel_points_1 = angle_acc * t_speedup_points
    t_uniform_circular_points = np.linspace(start= discretization_dt, stop=t_uniform_circular, num=int(t_uniform_circular/discretization_dt))
    angle_points_2 = angle_points_1[-1] + t_uniform_circular_points * v_average/radius
    anglevel_points_2 = t_uniform_circular_points * 0 + anglevel_points_1[-1]
    t_speeddown_points = np.linspace(start = discretization_dt, stop = t_speeddown, num = int(t_speeddown/discretization_dt))
    angle_points_3 = angle_points_2[-1] + v_average/radius * t_speeddown_points - 0.5 * angle_acc * t_speeddown_points**2
    anglevel_points_3 = anglevel_points_2[-1] - angle_acc * t_speeddown_points

    angle_points = np.concatenate((angle_points_1,angle_points_2,angle_points_3))
    anglevel_points = np.concatenate((anglevel_points_1,anglevel_points_2,anglevel_points_3))
    pos_traj_x = radius * np.sin(angle_points)
    pos_traj_y = radius * np.cos(angle_points)
    pos_traj_z = np.ones_like(pos_traj_x) * z
    vel_traj_x = anglevel_points * radius * np.cos(angle_points)
    vel_traj_y = anglevel_points * radius * np.sin(angle_points)
    ref = np.zeros((vel_traj_x.shape[0],12))
    ref[::,0] = pos_traj_x
    ref[::,1] = pos_traj_y
    ref[::,2] = pos_traj_z
    ref[::,6] = vel_traj_x
    ref[::,7] = vel_traj_y

    return ref
 
if __name__ == '__main__':
    
    measurementA = np.genfromtxt("nonlinear_test.out", delimiter=",")
    t_horizon = 1
    N = 20 # number of optimization nodes until time horizon
    dT = t_horizon/N
    down_sample_factor = 40
    """
    model = DT_gp_model(dT,200)
    model = DT_gp_model(dT,200)
    model = DT_gp_model(dT,200)

    model = DT_gp_model(dT,100)
    model = DT_gp_model(dT,100)
    model = DT_gp_model(dT,100)

    model = DT_gp_model(dT,50)
    model = DT_gp_model(dT,50)
    model = DT_gp_model(dT,50)

    model = DT_gp_model(dT,25)
    model = DT_gp_model(dT,25)
    model = DT_gp_model(dT,25)

    model = DT_gp_model(dT,12)
    model = DT_gp_model(dT,12)
    model = DT_gp_model(dT,12)

    model = DT_gp_model(dT,6)
    model = DT_gp_model(dT,6)
    model = DT_gp_model(dT,6)
    """
    model_GP = DT_gp_model(dT,6,'start')
    #model_GP_2 = DT_gp_model(dT,40)
    modelDT = DT_linear_model(dT)
    #model =linear_quad_model()

    
    #acados_solver = acados_settinngs_nonlinear_LS(model_GP,t_horizon = t_horizon,N=N,build=True, generate=True)
    #
    acados_solver = acados_settinngs_nonlinear_LS(model_GP,t_horizon = t_horizon,N=N,build=True, generate=True)
    
    #acados_solver = acados_settinngs_nonlinear_LS(model2,t_horizon = t_horizon,N=N,build=True, generate=False)
    #acados_solver = acados_settinngs_nonlinear_LS(model,t_horizon = t_horizon,N=N)
    #acados_solver2 = acados_settinngs_nonlinear_LS2(model2,t_horizon = t_horizon,N=N)
    
    
    #acados_solver = acados_settinngs_linear(model,t_horizon = t_horizon,N=N)
    #acados_solver = acados_settinngs_convex_nonlinear(model,t_horizon = t_horizon,N=N)
    
    pos_record = np.zeros((200,3))
    ref = set_loop_ref(discretization_dt = 0.05,radius = 8,z = 5,v_average = 4,sim_t = 50)
    # online GP buffer 
    online_buffer = np.array(np.zeros((12,20)))
    current_states = measurementA[:,0]
    control_input = np.zeros(4)

    for iindex in range(50):
        print('-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-')
        print('# of iter',iindex + 1)
        target = ref[iindex:iindex+N + 1]

        DT_result = solve_DT_nextState(modelDT,control_input ,current_states)
        current_states = measurementA[:,iindex]

        # save online error , error between (PX4) and (dynmic+GP offline).
        online_error = np.array(current_states-DT_result).T.squeeze(0)
        online_buffer = np.roll(online_buffer,1,axis = 1)
        online_buffer[:,0] = online_error
        #if iindex == 20:
            #for k in trange(100):
                #time.sleep(0.1)
	
        vx,vy,vz,p,q,r,control_input= run_solver(N=N,
                    acados_solver=acados_solver,initial_state = current_states,
                    ref=target)
        #if (iindex + 1) % 5 == 0:
            #acados_solver = acados_settinngs_nonlinear_LS(DT_gp_model(dT,iindex,iindex),t_horizon = t_horizon,N=N,build=True, generate=True)
        
        print(control_input)
        
        
        

    

